-- WARNING: Do NOT edit the input and output ports in this file in a text
-- editor if you plan to continue editing the block that represents it in
-- the Block Editor! File corruption is VERY likely to occur.

-- Copyright (C) 2017  Intel Corporation. All rights reserved.
-- Your use of Intel Corporation's design tools, logic functions
-- and other software and tools, and its AMPP partner logic
-- functions, and any output files from any of the foregoing
-- (including device programming or simulation files), and any
-- associated documentation or information are expressly subject
-- to the terms and conditions of the Intel Program License
-- Subscription Agreement, the Intel Quartus Prime License Agreement,
-- the Intel MegaCore Function License Agreement, or other
-- applicable license agreement, including, without limitation,
-- that your use is for the sole purpose of programming logic
-- devices manufactured by Intel and sold by Intel or its
-- authorized distributors.  Please refer to the applicable
-- agreement for further details.


-- Generated by Quartus Prime Version 17.0 (Build Build 595 04/25/2017)
-- Created on Mon Jan 07 01:01:25 2019

LIBRARY ieee;
USE ieee.std_logic_1164.all;


--  Entity Declaration

ENTITY ExpandKeys IS
	-- {{ALTERA_IO_BEGIN}} DO NOT REMOVE THIS LINE!
	PORT
	(
		Key : IN STD_LOGIC_VECTOR(127 downto 0);
		clk : IN STD_LOGIC;
		nrst : IN STD_LOGIC;
		start : IN STD_LOGIC;
		SBox_data : IN STD_LOGIC_VECTOR(7 downto 0);
		SBox_command : OUT STD_LOGIC_VECTOR(7 downto 0);
		Key_I : OUT STD_LOGIC_VECTOR(127 downto 0)
	);
	-- {{ALTERA_IO_END}} DO NOT REMOVE THIS LINE!

END ExpandKeys;


--  Architecture Body

ARCHITECTURE ExpandKeys_architecture OF ExpandKeys IS
  
  BEGIN
  
  KeyExpansion : process(clk, nrst)
  
  variable word0 : std_logic_vector(31 downto 0) := x"00000000";
  variable word1 : std_logic_vector(31 downto 0) := x"00000000";
  variable word2 : std_logic_vector(31 downto 0) := x"00000000";
  variable word3 : std_logic_vector(31 downto 0) := x"00000000";
  variable counter : std_logic_vector(7 downto 0) := x"00";
  variable rcon : std_logic_vector(7 downto 0) := x"00";
  
  function addone(source : std_logic_vector(7 downto 0)) return std_logic_vector is
  
  variable overflow : boolean := false;
  variable tmp : std_logic_vector(7 downto 0) := x"00";
  
  begin
    tmp := source;
	 
	 for c in 0 to 7 loop
	 
	   if(tmp(c) = '1') then
	     overflow := true;
      elsif(overflow = true) then
	     tmp(c) :='1';
		  return tmp;
		else
		  return tmp(7 downto 1) & '1';
	   end if;
		
	 end loop;
	 
	 return tmp;
	 
  end function addone;
  
  function rotWord(source : std_logic_vector(31 downto 0)) return std_logic_vector is
  begin
    return source(23 downto 0) & source(31 downto 24);
  end function rotWord;
  
  impure function subWord(source : std_logic_vector(31 downto 0)) return std_logic_vector is
    variable sbox0 : std_logic_vector(7 downto 0) := x"00";
	 variable sbox1 : std_logic_vector(7 downto 0) := x"00";
	 variable sbox2 : std_logic_vector(7 downto 0) := x"00";
	 variable sbox3 : std_logic_vector(7 downto 0) := x"00";
  begin
    SBox_command <= source(31 downto 24);
	 sbox0 := SBox_data;
	 SBox_command <= source(23 downto 16);
	 sbox1 := SBox_data;
	 SBox_command <= source(15 downto 8);
	 sbox2 := SBox_data;
	 SBox_command <= source(7 downto 0);
	 sbox3 := SBox_data;
	 return sbox0 & sbox1 & sbox2 & sbox3;
  end function subWord;
  
  function oneExpandRound(lastWord, minusNk : std_logic_vector(31 downto 0);
                          rcon : std_logic_vector(7 downto 0))
								  return std_logic_vector is

  variable tmp : std_logic_vector(31 downto 0) := x"00000000";								  
								  
  begin
    tmp := lastWord;
    tmp := rotWord(tmp);
	 tmp := subWord(tmp);
	 return tmp xor rcon & x"000000" xor minusNk;
  end function oneExpandRound;
  
  begin
  
    if(nrst = '1' or start ='0') then
      word0 := x"00000000";
	   word1 := x"00000000";
	   word2 := x"00000000";
	   word3 := x"00000000";
	   counter := x"00";
		
    elsif(rising_edge(clk) and start = '1') then
	 
	   if(counter = X"00") then
		  word0 := Key(127 downto 96);
		  word1 := Key(95 downto 64);
		  word2 := Key(63 downto 32);
		  word3 := Key(31 downto 0);
		  counter := x"04";
		  rcon := x"01";
		else
		  word0 := oneExpandRound(word3, word0, rcon);
		  word1 := oneExpandRound(word0, word1, rcon);
		  word2 := oneExpandRound(word1, word2, rcon);
		  word3 := oneExpandRound(word2, word3, rcon);
		  rcon := addone(rcon);
		end if;

		Key_I <= word0 & word1 & word2 & word3;
		
	 end if;
  end process;
  
END ExpandKeys_architecture;